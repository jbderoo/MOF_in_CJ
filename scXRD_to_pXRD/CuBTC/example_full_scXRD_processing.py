# -*- coding: utf-8 -*-
"""
Created on Tue May  4 18:15:33 2021

@author: jderoo
"""

import numpy as np
import matplotlib.pyplot as plt
import fabio
from xrd_tools import xrd_extract, find_max, theta_integration, pixel_to_theta, dspace_convert
import sys


# ---- open known CuBTC data -----
# this was generated by predicting the pXRD pattern from the known CuBRC crystal structure in VESTA

with open('perfect_CuBTC.npy', 'rb') as f:
    x = np.load(f)
    y = np.load(f)
    


# ---- open img and convert to data matrix -----
img_path = './2D-02_1/2D-02_1_0001.img'
img = fabio.open(img_path)
data = img.data


# ---- extract meaningful info from image metadata -----
x_center, y_center, x_pixel, y_pixel, wl, distance = xrd_extract(img, 'synch', verbose=True)


# ---- perform azimuthal integration -----

pixel_range = [0, max([x_center, y_center])] # yields full integration
pixel_range = [100, 700] # big picture with meaningful data
pixel_range = [225, 550] # most meaningful data
dp = 10 # the thickness of the pixel's reading: e.g. at pixel 100, it reads 
        # pixel intensities at 95-105 and averages them to 100
        # affects smoothness/clarity of plot
 
n  = 100 # number of azimuthal slices taken between the pixel range, affects 
         # affects resolution of plot (and time to run)

pixels, pixel_average = theta_integration(data, pixel_range, dp, n, x_center, y_center)

#fig, ax = plt.subplots(dpi=600)
#ax.plot(pixels, pixel_average, 'g')

# ---- instead of performing it every time, I have it saved and loaded in. Faster. 
# commented out for publication purposes
# with open('ringed_pixels.npy', 'rb') as f:
#     r   = np.load(f)
#     it  = np.load(f)

r  = pixels
it = pixel_average


# --- CuBTC lattice length and first 4 peaks and their miller indicies
a  = 2.6343 # nm
h = [2, 2, 2]#, 0]
k = [0, 2, 2]#, 0]
l = [0, 0, 2]#, 4]
dspace = []
theta2 = []


# --- Bragg's angle from miller indices ----
for i in range(0, len(h)):
    dist = a / (np.sqrt(h[i]**2 +k[i]**2 +l[i]**2))
    dspace.append(dist*10)
    
    theta = 2*np.rad2deg(np.arcsin(wl/(2*dist)))   
    theta2.append(theta)

x_og = x_center
y_og = y_center
n = 575


# bound/extract the meaningful data together
wdata = data[y_og-n:y_og+n, x_og-n:x_og+n]

#---- find pixel local maxima -----
# used for peak alignment error calc
bnd1 = [250, 300]
x1, y1  = find_max(bnd1, r, it) 

bnd1 = [350, 400]
x2, y2  = find_max(bnd1, r, it) 

bnd1 = [450, 500]
x3, y3  = find_max(bnd1, r, it) 

bnd1 = [525, 575]
x4, y4  = find_max(bnd1, r, it) 

allx_it = [x1, x2, x3]#, x4]
ally_it = [y1, y2, y3]#, y4]


# ---- copy pasted first 4 x-value of CuBTC pXRD
# data came from simulated pXRD pattern of CuBTC from VESTA
ppeaks = [6.73438549973071, 9.50924208201468, 11.6515945903957]#, 13.4674933832139]


# --- limit max ring to 600 instead of 1200 for plotting clarity ---
for i in range(0,len(y)):
    if y[i] >= 390:
        y[i] = 390

# a linear adjustment in the data, left/right for extracted values
shift = -0.205 # making this -0.205 lines up the 3 investigative peaks perfectly.
          # this linear error could be attributed to... ?

# --- convert from pixels to Bragg's angle 2theta ----
maxpxrd = max(y)
base = 100
converted_Braggs_2theta, rescaled_intensity_to_count = pixel_to_theta(img, 'synch', r, it, maxpxrd, base)

# This guy is used to highlight peaks/alignment error, not critical
# the math done here is similar to what's executed in pixel_to_theta
fixedxrd  = 1.54/1.0001*np.rad2deg(np.arctan(np.array(allx_it)*x_pixel/distance))+shift


err = (ppeaks-fixedxrd)/ppeaks*100
for i in range(0,len(err)):    
    print(f'the error for peak {i+1} is: {err[i]:1.2}%')


# ---- plot all SCXRD data -----
fig, ax = plt.subplots()
plt.imshow(data*500, cmap="gray_r")


# ---- plot only meaningful SCXRD data -----
fig, ax = plt.subplots()
plt.imshow(wdata*500, cmap="gray_r")


# ---- plot known CuBTC pXRD/fingerprint and the processed, extracted data -----    
fig, ax = plt.subplots(dpi=600)
ax.plot(x, y, 'g')
ax.plot(converted_Braggs_2theta+shift, rescaled_intensity_to_count, 'k')
plt.xlabel('2\u03B8 (degrees)')
plt.ylabel('Counts')
plt.title('CuBTC PXRD')    
plt.xlim(left=5, right=17)
plt.ylim(bottom=0, top = 400)


# --- plot d space of CuBTC -----
dspace = dspace_convert(img, r, 'synch')
fig, ax = plt.subplots(dpi=600)
ax.plot(dspace, rescaled_intensity_to_count,'g')
